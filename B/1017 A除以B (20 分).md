1017 A除以B (20 分)

## 1 题目描述

本题要求计算 *A*/*B*，其中 *A* 是不超过 1000 位的正整数，*B* 是 1 位正整数。你需要输出商数 *Q* 和余数 *R*，使得 *A*=*B*×*Q*+*R* 成立。

### 输入格式：

输入在一行中依次给出 *A* 和 *B*，中间以 1 空格分隔。

### 输出格式：

在一行中依次输出 *Q* 和 *R*，中间以 1 空格分隔。

### 输入样例：

```in
123456789050987654321 7
```

### 输出样例：

```out
17636684150141093474 3
```



## 2 解答

### C++：

简单思路：因为题目所说A是不超过1000位的整数，故第一想法是利用char[1000]数组来存放输入的A，每一个位置存放一个数字。因为要求A/B的除数，故依次从高位到低位遍历A数组与B相除，除数保留在int arr_get[1000]数组中。如果能除断就除；如果不行就循环到低位，保留高位*10 + 低位 除B，依次循环到最后。（除的过程中要保留余数）

考虑最后一个边界值，故最后一个余数不进入循环中计算。同时在输出时，如果arr_get数组长度为1位，则第一个数如果为0则输出，反之，不输出首位为0。

```cpp
#include<iostream>
using namespace std;
#include<cstring>

int main()
{
	char arr[1000];
	int B;
	int tem = 0; // 临时变量
	int arr_get[1000]; // 存放除数
	cin >> arr >> B;
	int i;
	for (i = 0; i < strlen(arr); i++)
	{
		arr_get[i] = (tem * 10 + (arr[i] - '0')) / B;
		tem = (tem * 10 + (arr[i] - '0')) - arr_get[i] * B;
	}
	arr_get[i] = (tem * 10 + (arr[i] - '0')) / B; // 保留最后一个余数
	for (int j = 0; j <= strlen(arr) - 1; j++)
	{
		if (i != 1) // 如果为1位，那么首位为0则输出；反之不输出
		{
			if (j == 0 && arr_get[j] == 0)
			{
				continue;
			}
		}
		cout << arr_get[j];
	}
	cout << " " << tem << endl;
}
```



