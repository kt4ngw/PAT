## 1 题目

**1008 数组元素循环右移问题**

一个数组*A*中存有*N*（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移*M*（≥0）个位置，即将*A*中的数据由（*A_{0}A_{1}...A_{N-1}*）变换为（*A_{N-M}⋯A_{N−1}A_{0}A_{1}⋯A_{N−M−1}*）（最后*M*个数循环移至最前面的*M*个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

### 输入格式:

每个输入包含一个测试用例，第1行输入*N*（1≤*N*≤100）和*M*（≥0）；第2行输入*N*个整数，之间用空格分隔。

### 输出格式:

在一行中输出循环右移*M*位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

### 输入样例:

```in
6 2
1 2 3 4 5 6
```

### 输出样例:

```out
5 6 1 2 3 4
```

## 2 解答

思路：因为题中不允许用新数组来充当临时空间，又看到输入输出样例是直接结果，所以笔者想法就是直接输出结果；
而没有考虑更改数组A AA内的数据，也有不严谨之处；
至于移动次数最少，笔者目前水平没有好的想法；
如读者有好的想法，欢迎您私信邮箱 kt4ngw@163.com

C代码

```c
#include<stdio.h>
int main()
{
	int N,M; //N个数，M的循环右移
	scanf("%d %d", &N,&M);
	M=M%N;
	int A[N];
	int i,a,k;
	for(i=0;i<N;i++)
	{
	    scanf("%d",&A[i]);
	} 
	for(i=0;i<M;i++)
	{
		printf("%d ",A[N-M+i]); // 先输出后面M个元素 
	}
	for(i=0;i<N-M-1;i++) // 再输出前面N-M元素的循环
	{
	printf("%d ",A[i]);	 
	}
	printf("%d",A[i]); // 最后不能拥有空格 
}
```

